// Copyright 2010 The Emscripten Authors.  All rights reserved.
// Emscripten is available under two separate licenses, the MIT license and the
// University of Illinois/NCSA Open Source License.  Both these licenses can be
// found in the LICENSE file.

// The Module object: Our interface to the outside world. We import
// and export values on it. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(Module) { ..generated code.. }
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to check if Module already exists (e.g. case 3 above).
// Substitution will be replaced with actual code on later stage of the build,
// this way Closure Compiler will not mangle it (e.g. case 4. above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module = typeof Module !== 'undefined' ? Module : {};

// --pre-jses are emitted after the Module integration code, so that they can
// refer to Module (if they choose; they can also define Module)


// Sometimes an existing Module object exists with properties
// meant to overwrite the default module functionality. Here
// we collect those properties and reapply _after_ we configure
// the current environment's defaults to avoid having to be so
// defensive during initialization.
var moduleOverrides = {};
var key;
for (key in Module) {
  if (Module.hasOwnProperty(key)) {
    moduleOverrides[key] = Module[key];
  }
}

Module['arguments'] = [];
Module['thisProgram'] = './this.program';
Module['quit'] = function(status, toThrow) {
  throw toThrow;
};
Module['preRun'] = [];
Module['postRun'] = [];

// Determine the runtime environment we are in. You can customize this by
// setting the ENVIRONMENT setting at compile time (see settings.js).

var ENVIRONMENT_IS_WEB = false;
var ENVIRONMENT_IS_WORKER = false;
var ENVIRONMENT_IS_NODE = false;
var ENVIRONMENT_IS_SHELL = false;
ENVIRONMENT_IS_WEB = typeof window === 'object';
ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';
ENVIRONMENT_IS_NODE = typeof process === 'object' && typeof require === 'function' && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;
ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;



// Three configurations we can be running in:
// 1) We could be the application main() thread running in the main JS UI thread. (ENVIRONMENT_IS_WORKER == false and ENVIRONMENT_IS_PTHREAD == false)
// 2) We could be the application main() thread proxied to worker. (with Emscripten -s PROXY_TO_WORKER=1) (ENVIRONMENT_IS_WORKER == true, ENVIRONMENT_IS_PTHREAD == false)
// 3) We could be an application pthread running in a worker. (ENVIRONMENT_IS_WORKER == true and ENVIRONMENT_IS_PTHREAD == true)




// `/` should be present at the end if `scriptDirectory` is not empty
var scriptDirectory = '';
function locateFile(path) {
  if (Module['locateFile']) {
    return Module['locateFile'](path, scriptDirectory);
  } else {
    return scriptDirectory + path;
  }
}

if (ENVIRONMENT_IS_NODE) {
  scriptDirectory = __dirname + '/';

  // Expose functionality in the same simple way that the shells work
  // Note that we pollute the global namespace here, otherwise we break in node
  var nodeFS;
  var nodePath;

  Module['read'] = function shell_read(filename, binary) {
    var ret;
    ret = tryParseAsDataURI(filename);
    if (!ret) {
      if (!nodeFS) nodeFS = require('fs');
      if (!nodePath) nodePath = require('path');
      filename = nodePath['normalize'](filename);
      ret = nodeFS['readFileSync'](filename);
    }
    return binary ? ret : ret.toString();
  };

  Module['readBinary'] = function readBinary(filename) {
    var ret = Module['read'](filename, true);
    if (!ret.buffer) {
      ret = new Uint8Array(ret);
    }
    assert(ret.buffer);
    return ret;
  };

  if (process['argv'].length > 1) {
    Module['thisProgram'] = process['argv'][1].replace(/\\/g, '/');
  }

  Module['arguments'] = process['argv'].slice(2);

  if (typeof module !== 'undefined') {
    module['exports'] = Module;
  }

  process['on']('uncaughtException', function(ex) {
    // suppress ExitStatus exceptions from showing an error
    if (!(ex instanceof ExitStatus)) {
      throw ex;
    }
  });
  // Currently node will swallow unhandled rejections, but this behavior is
  // deprecated, and in the future it will exit with error status.
  process['on']('unhandledRejection', abort);

  Module['quit'] = function(status) {
    process['exit'](status);
  };

  Module['inspect'] = function () { return '[Emscripten Module object]'; };
} else
if (ENVIRONMENT_IS_SHELL) {


  if (typeof read != 'undefined') {
    Module['read'] = function shell_read(f) {
      var data = tryParseAsDataURI(f);
      if (data) {
        return intArrayToString(data);
      }
      return read(f);
    };
  }

  Module['readBinary'] = function readBinary(f) {
    var data;
    data = tryParseAsDataURI(f);
    if (data) {
      return data;
    }
    if (typeof readbuffer === 'function') {
      return new Uint8Array(readbuffer(f));
    }
    data = read(f, 'binary');
    assert(typeof data === 'object');
    return data;
  };

  if (typeof scriptArgs != 'undefined') {
    Module['arguments'] = scriptArgs;
  } else if (typeof arguments != 'undefined') {
    Module['arguments'] = arguments;
  }

  if (typeof quit === 'function') {
    Module['quit'] = function(status) {
      quit(status);
    }
  }
} else
if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled
    scriptDirectory = self.location.href;
  } else if (document.currentScript) { // web
    scriptDirectory = document.currentScript.src;
  }
  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.
  // otherwise, slice off the final part of the url to find the script directory.
  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,
  // and scriptDirectory will correctly be replaced with an empty string.
  if (scriptDirectory.indexOf('blob:') !== 0) {
    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf('/')+1);
  } else {
    scriptDirectory = '';
  }


  Module['read'] = function shell_read(url) {
    try {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, false);
      xhr.send(null);
      return xhr.responseText;
    } catch (err) {
      var data = tryParseAsDataURI(url);
      if (data) {
        return intArrayToString(data);
      }
      throw err;
    }
  };

  if (ENVIRONMENT_IS_WORKER) {
    Module['readBinary'] = function readBinary(url) {
      try {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, false);
        xhr.responseType = 'arraybuffer';
        xhr.send(null);
        return new Uint8Array(xhr.response);
      } catch (err) {
        var data = tryParseAsDataURI(url);
        if (data) {
          return data;
        }
        throw err;
      }
    };
  }

  Module['readAsync'] = function readAsync(url, onload, onerror) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'arraybuffer';
    xhr.onload = function xhr_onload() {
      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0
        onload(xhr.response);
        return;
      }
      var data = tryParseAsDataURI(url);
      if (data) {
        onload(data.buffer);
        return;
      }
      onerror();
    };
    xhr.onerror = onerror;
    xhr.send(null);
  };

  Module['setWindowTitle'] = function(title) { document.title = title };
} else
{
}

// Set up the out() and err() hooks, which are how we can print to stdout or
// stderr, respectively.
// If the user provided Module.print or printErr, use that. Otherwise,
// console.log is checked first, as 'print' on the web will open a print dialogue
// printErr is preferable to console.warn (works better in shells)
// bind(console) is necessary to fix IE/Edge closed dev tools panel behavior.
var out = Module['print'] || (typeof console !== 'undefined' ? console.log.bind(console) : (typeof print !== 'undefined' ? print : null));
var err = Module['printErr'] || (typeof printErr !== 'undefined' ? printErr : ((typeof console !== 'undefined' && console.warn.bind(console)) || out));

// Merge back in the overrides
for (key in moduleOverrides) {
  if (moduleOverrides.hasOwnProperty(key)) {
    Module[key] = moduleOverrides[key];
  }
}
// Free the object hierarchy contained in the overrides, this lets the GC
// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.
moduleOverrides = undefined;

// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message



// Copyright 2017 The Emscripten Authors.  All rights reserved.
// Emscripten is available under two separate licenses, the MIT license and the
// University of Illinois/NCSA Open Source License.  Both these licenses can be
// found in the LICENSE file.

// {{PREAMBLE_ADDITIONS}}

var STACK_ALIGN = 16;


function dynamicAlloc(size) {
  var ret = HEAP32[DYNAMICTOP_PTR>>2];
  var end = (ret + size + 15) & -16;
  if (end <= _emscripten_get_heap_size()) {
    HEAP32[DYNAMICTOP_PTR>>2] = end;
  } else {
    var success = _emscripten_resize_heap(end);
    if (!success) return 0;
  }
  return ret;
}

function alignMemory(size, factor) {
  if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default
  return Math.ceil(size / factor) * factor;
}

function getNativeTypeSize(type) {
  switch (type) {
    case 'i1': case 'i8': return 1;
    case 'i16': return 2;
    case 'i32': return 4;
    case 'i64': return 8;
    case 'float': return 4;
    case 'double': return 8;
    default: {
      if (type[type.length-1] === '*') {
        return 4; // A pointer
      } else if (type[0] === 'i') {
        var bits = parseInt(type.substr(1));
        assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);
        return bits / 8;
      } else {
        return 0;
      }
    }
  }
}

function warnOnce(text) {
  if (!warnOnce.shown) warnOnce.shown = {};
  if (!warnOnce.shown[text]) {
    warnOnce.shown[text] = 1;
    err(text);
  }
}

var asm2wasmImports = { // special asm2wasm imports
    "f64-rem": function(x, y) {
        return x % y;
    },
    "debugger": function() {
        debugger;
    }
};



var jsCallStartIndex = 1;
var functionPointers = new Array(0);

// Wraps a JS function as a wasm function with a given signature.
// In the future, we may get a WebAssembly.Function constructor. Until then,
// we create a wasm module that takes the JS function as an import with a given
// signature, and re-exports that as a wasm function.
function convertJsFunctionToWasm(func, sig) {
  // The module is static, with the exception of the type section, which is
  // generated based on the signature passed in.
  var typeSection = [
    0x01, // id: section,
    0x00, // length: 0 (placeholder)
    0x01, // count: 1
    0x60, // form: func
  ];
  var sigRet = sig.slice(0, 1);
  var sigParam = sig.slice(1);
  var typeCodes = {
    'i': 0x7f, // i32
    'j': 0x7e, // i64
    'f': 0x7d, // f32
    'd': 0x7c, // f64
  };

  // Parameters, length + signatures
  typeSection.push(sigParam.length);
  for (var i = 0; i < sigParam.length; ++i) {
    typeSection.push(typeCodes[sigParam[i]]);
  }

  // Return values, length + signatures
  // With no multi-return in MVP, either 0 (void) or 1 (anything else)
  if (sigRet == 'v') {
    typeSection.push(0x00);
  } else {
    typeSection = typeSection.concat([0x01, typeCodes[sigRet]]);
  }

  // Write the overall length of the type section back into the section header
  // (excepting the 2 bytes for the section id and length)
  typeSection[1] = typeSection.length - 2;

  // Rest of the module is static
  var bytes = new Uint8Array([
    0x00, 0x61, 0x73, 0x6d, // magic ("\0asm")
    0x01, 0x00, 0x00, 0x00, // version: 1
  ].concat(typeSection, [
    0x02, 0x07, // import section
      // (import "e" "f" (func 0 (type 0)))
      0x01, 0x01, 0x65, 0x01, 0x66, 0x00, 0x00,
    0x07, 0x05, // export section
      // (export "f" (func 0 (type 0)))
      0x01, 0x01, 0x66, 0x00, 0x00,
  ]));

   // We can compile this wasm module synchronously because it is very small.
  // This accepts an import (at "e.f"), that it reroutes to an export (at "f")
  var module = new WebAssembly.Module(bytes);
  var instance = new WebAssembly.Instance(module, {
    e: {
      f: func
    }
  });
  var wrappedFunc = instance.exports.f;
  return wrappedFunc;
}

// Add a wasm function to the table.
function addFunctionWasm(func, sig) {
  var table = wasmTable;
  var ret = table.length;

  // Grow the table
  try {
    table.grow(1);
  } catch (err) {
    if (!err instanceof RangeError) {
      throw err;
    }
    throw 'Unable to grow wasm table. Use a higher value for RESERVED_FUNCTION_POINTERS or set ALLOW_TABLE_GROWTH.';
  }

  // Insert new element
  try {
    // Attempting to call this with JS function will cause of table.set() to fail
    table.set(ret, func);
  } catch (err) {
    if (!err instanceof TypeError) {
      throw err;
    }
    assert(typeof sig !== 'undefined', 'Missing signature argument to addFunction');
    var wrapped = convertJsFunctionToWasm(func, sig);
    table.set(ret, wrapped);
  }

  return ret;
}

function removeFunctionWasm(index) {
  // TODO(sbc): Look into implementing this to allow re-using of table slots
}

// 'sig' parameter is required for the llvm backend but only when func is not
// already a WebAssembly function.
function addFunction(func, sig) {


  var base = 0;
  for (var i = base; i < base + 0; i++) {
    if (!functionPointers[i]) {
      functionPointers[i] = func;
      return jsCallStartIndex + i;
    }
  }
  throw 'Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.';

}

function removeFunction(index) {

  functionPointers[index-jsCallStartIndex] = null;
}

var funcWrappers = {};

function getFuncWrapper(func, sig) {
  if (!func) return; // on null pointer, return undefined
  assert(sig);
  if (!funcWrappers[sig]) {
    funcWrappers[sig] = {};
  }
  var sigCache = funcWrappers[sig];
  if (!sigCache[func]) {
    // optimize away arguments usage in common cases
    if (sig.length === 1) {
      sigCache[func] = function dynCall_wrapper() {
        return dynCall(sig, func);
      };
    } else if (sig.length === 2) {
      sigCache[func] = function dynCall_wrapper(arg) {
        return dynCall(sig, func, [arg]);
      };
    } else {
      // general case
      sigCache[func] = function dynCall_wrapper() {
        return dynCall(sig, func, Array.prototype.slice.call(arguments));
      };
    }
  }
  return sigCache[func];
}


function makeBigInt(low, high, unsigned) {
  return unsigned ? ((+((low>>>0)))+((+((high>>>0)))*4294967296.0)) : ((+((low>>>0)))+((+((high|0)))*4294967296.0));
}

function dynCall(sig, ptr, args) {
  if (args && args.length) {
    return Module['dynCall_' + sig].apply(null, [ptr].concat(args));
  } else {
    return Module['dynCall_' + sig].call(null, ptr);
  }
}

var tempRet0 = 0;

var setTempRet0 = function(value) {
  tempRet0 = value;
}

var getTempRet0 = function() {
  return tempRet0;
}


var Runtime = {
};

// The address globals begin at. Very low in memory, for code size and optimization opportunities.
// Above 0 is static memory, starting with globals.
// Then the stack.
// Then 'dynamic' memory for sbrk.
var GLOBAL_BASE = 1024;




// === Preamble library stuff ===

// Documentation for the public APIs defined in this file must be updated in:
//    site/source/docs/api_reference/preamble.js.rst
// A prebuilt local version of the documentation is available at:
//    site/build/text/docs/api_reference/preamble.js.txt
// You can also build docs locally as HTML or other formats in site/
// An online HTML version (which may be of a different version of Emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html


if (typeof WebAssembly !== 'object') {
  err('no native wasm support detected');
}


/** @type {function(number, string, boolean=)} */
function getValue(ptr, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': return HEAP8[((ptr)>>0)];
      case 'i8': return HEAP8[((ptr)>>0)];
      case 'i16': return HEAP16[((ptr)>>1)];
      case 'i32': return HEAP32[((ptr)>>2)];
      case 'i64': return HEAP32[((ptr)>>2)];
      case 'float': return HEAPF32[((ptr)>>2)];
      case 'double': return HEAPF64[((ptr)>>3)];
      default: abort('invalid type for getValue: ' + type);
    }
  return null;
}




// Wasm globals

var wasmMemory;

// Potentially used for direct table calls.
var wasmTable;


//========================================
// Runtime essentials
//========================================

// whether we are quitting the application. no code should run after this.
// set in exit() and abort()
var ABORT = false;

// set by exit() and abort().  Passed to 'onExit' handler.
// NOTE: This is also used as the process return code code in shell environments
// but only when noExitRuntime is false.
var EXITSTATUS = 0;

/** @type {function(*, string=)} */
function assert(condition, text) {
  if (!condition) {
    abort('Assertion failed: ' + text);
  }
}

// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)
function getCFunc(ident) {
  var func = Module['_' + ident]; // closure exported function
  assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');
  return func;
}

// C calling interface.
function ccall(ident, returnType, argTypes, args, opts) {
  // For fast lookup of conversion functions
  var toC = {
    'string': function(str) {
      var ret = 0;
      if (str !== null && str !== undefined && str !== 0) { // null string
        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\0'
        var len = (str.length << 2) + 1;
        ret = stackAlloc(len);
        stringToUTF8(str, ret, len);
      }
      return ret;
    },
    'array': function(arr) {
      var ret = stackAlloc(arr.length);
      writeArrayToMemory(arr, ret);
      return ret;
    }
  };

  function convertReturnValue(ret) {
    if (returnType === 'string') return UTF8ToString(ret);
    if (returnType === 'boolean') return Boolean(ret);
    return ret;
  }

  var func = getCFunc(ident);
  var cArgs = [];
  var stack = 0;
  if (args) {
    for (var i = 0; i < args.length; i++) {
      var converter = toC[argTypes[i]];
      if (converter) {
        if (stack === 0) stack = stackSave();
        cArgs[i] = converter(args[i]);
      } else {
        cArgs[i] = args[i];
      }
    }
  }
  var ret = func.apply(null, cArgs);
  ret = convertReturnValue(ret);
  if (stack !== 0) stackRestore(stack);
  return ret;
}

function cwrap(ident, returnType, argTypes, opts) {
  argTypes = argTypes || [];
  // When the function takes numbers and returns a number, we can just return
  // the original function
  var numericArgs = argTypes.every(function(type){ return type === 'number'});
  var numericRet = returnType !== 'string';
  if (numericRet && numericArgs && !opts) {
    return getCFunc(ident);
  }
  return function() {
    return ccall(ident, returnType, argTypes, arguments, opts);
  }
}

/** @type {function(number, number, string, boolean=)} */
function setValue(ptr, value, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': HEAP8[((ptr)>>0)]=value; break;
      case 'i8': HEAP8[((ptr)>>0)]=value; break;
      case 'i16': HEAP16[((ptr)>>1)]=value; break;
      case 'i32': HEAP32[((ptr)>>2)]=value; break;
      case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)]=tempI64[0],HEAP32[(((ptr)+(4))>>2)]=tempI64[1]); break;
      case 'float': HEAPF32[((ptr)>>2)]=value; break;
      case 'double': HEAPF64[((ptr)>>3)]=value; break;
      default: abort('invalid type for setValue: ' + type);
    }
}

var ALLOC_NORMAL = 0; // Tries to use _malloc()
var ALLOC_STACK = 1; // Lives for the duration of the current function call
var ALLOC_DYNAMIC = 2; // Cannot be freed except through sbrk
var ALLOC_NONE = 3; // Do not allocate

// allocate(): This is for internal use. You can use it yourself as well, but the interface
//             is a little tricky (see docs right below). The reason is that it is optimized
//             for multiple syntaxes to save space in generated code. So you should
//             normally not use allocate(), and instead allocate memory using _malloc(),
//             initialize it with setValue(), and so forth.
// @slab: An array of data, or a number. If a number, then the size of the block to allocate,
//        in *bytes* (note that this is sometimes confusing: the next parameter does not
//        affect this!)
// @types: Either an array of types, one for each byte (or 0 if no type at that position),
//         or a single type which is used for the entire block. This only matters if there
//         is initial data - if @slab is a number, then this does not matter at all and is
//         ignored.
// @allocator: How to allocate memory, see ALLOC_*
/** @type {function((TypedArray|Array<number>|number), string, number, number=)} */
function allocate(slab, types, allocator, ptr) {
  var zeroinit, size;
  if (typeof slab === 'number') {
    zeroinit = true;
    size = slab;
  } else {
    zeroinit = false;
    size = slab.length;
  }

  var singleType = typeof types === 'string' ? types : null;

  var ret;
  if (allocator == ALLOC_NONE) {
    ret = ptr;
  } else {
    ret = [_malloc,
    stackAlloc,
    dynamicAlloc][allocator](Math.max(size, singleType ? 1 : types.length));
  }

  if (zeroinit) {
    var stop;
    ptr = ret;
    assert((ret & 3) == 0);
    stop = ret + (size & ~3);
    for (; ptr < stop; ptr += 4) {
      HEAP32[((ptr)>>2)]=0;
    }
    stop = ret + size;
    while (ptr < stop) {
      HEAP8[((ptr++)>>0)]=0;
    }
    return ret;
  }

  if (singleType === 'i8') {
    if (slab.subarray || slab.slice) {
      HEAPU8.set(/** @type {!Uint8Array} */ (slab), ret);
    } else {
      HEAPU8.set(new Uint8Array(slab), ret);
    }
    return ret;
  }

  var i = 0, type, typeSize, previousType;
  while (i < size) {
    var curr = slab[i];

    type = singleType || types[i];
    if (type === 0) {
      i++;
      continue;
    }

    if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later

    setValue(ret+i, curr, type);

    // no need to look up size unless type changes, so cache it
    if (previousType !== type) {
      typeSize = getNativeTypeSize(type);
      previousType = type;
    }
    i += typeSize;
  }

  return ret;
}

// Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready
function getMemory(size) {
  if (!runtimeInitialized) return dynamicAlloc(size);
  return _malloc(size);
}




/** @type {function(number, number=)} */
function Pointer_stringify(ptr, length) {
  abort("this function has been removed - you should use UTF8ToString(ptr, maxBytesToRead) instead!");
}

// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

function AsciiToString(ptr) {
  var str = '';
  while (1) {
    var ch = HEAPU8[((ptr++)>>0)];
    if (!ch) return str;
    str += String.fromCharCode(ch);
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.

function stringToAscii(str, outPtr) {
  return writeAsciiToMemory(str, outPtr, false);
}


// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns
// a copy of that string as a Javascript String object.

var UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;

/**
 * @param {number} idx
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ArrayToString(u8Array, idx, maxBytesToRead) {
  var endIdx = idx + maxBytesToRead;
  var endPtr = idx;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  // (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)
  while (u8Array[endPtr] && !(endPtr >= endIdx)) ++endPtr;

  if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {
    return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));
  } else {
    var str = '';
    // If building with TextDecoder, we have already computed the string length above, so test loop end condition against that
    while (idx < endPtr) {
      // For UTF8 byte structure, see:
      // http://en.wikipedia.org/wiki/UTF-8#Description
      // https://www.ietf.org/rfc/rfc2279.txt
      // https://tools.ietf.org/html/rfc3629
      var u0 = u8Array[idx++];
      if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
      var u1 = u8Array[idx++] & 63;
      if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
      var u2 = u8Array[idx++] & 63;
      if ((u0 & 0xF0) == 0xE0) {
        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
      } else {
        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (u8Array[idx++] & 63);
      }

      if (u0 < 0x10000) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 0x10000;
        str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
      }
    }
  }
  return str;
}

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a
// copy of that string as a Javascript String object.
// maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit
//                 this parameter to scan the string until the first \0 byte. If maxBytesToRead is
//                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the
//                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will
//                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)
//                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may
//                 throw JS JIT optimizations off, so it is worth to consider consistently using one
//                 style or the other.
/**
 * @param {number} ptr
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ToString(ptr, maxBytesToRead) {
  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
}

// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',
// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outU8Array: the array to copy to. Each index in this array is assumed to be one 8-byte element.
//   outIdx: The starting offset in the array to begin the copying.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array.
//                    This count should include the null terminator,
//                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.
//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {
  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.
    return 0;

  var startIdx = outIdx;
  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) {
      var u1 = str.charCodeAt(++i);
      u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);
    }
    if (u <= 0x7F) {
      if (outIdx >= endIdx) break;
      outU8Array[outIdx++] = u;
    } else if (u <= 0x7FF) {
      if (outIdx + 1 >= endIdx) break;
      outU8Array[outIdx++] = 0xC0 | (u >> 6);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0xFFFF) {
      if (outIdx + 2 >= endIdx) break;
      outU8Array[outIdx++] = 0xE0 | (u >> 12);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else {
      if (outIdx + 3 >= endIdx) break;
      outU8Array[outIdx++] = 0xF0 | (u >> 18);
      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    }
  }
  // Null-terminate the pointer to the buffer.
  outU8Array[outIdx] = 0;
  return outIdx - startIdx;
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8(str, outPtr, maxBytesToWrite) {
  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.
function lengthBytesUTF8(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    if (u <= 0x7F) ++len;
    else if (u <= 0x7FF) len += 2;
    else if (u <= 0xFFFF) len += 3;
    else len += 4;
  }
  return len;
}


// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

var UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;
function UTF16ToString(ptr) {
  var endPtr = ptr;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  var idx = endPtr >> 1;
  while (HEAP16[idx]) ++idx;
  endPtr = idx << 1;

  if (endPtr - ptr > 32 && UTF16Decoder) {
    return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
  } else {
    var i = 0;

    var str = '';
    while (1) {
      var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];
      if (codeUnit == 0) return str;
      ++i;
      // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.
      str += String.fromCharCode(codeUnit);
    }
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.
// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF16(str, outPtr, maxBytesToWrite) {
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 2) return 0;
  maxBytesToWrite -= 2; // Null terminator.
  var startPtr = outPtr;
  var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;
  for (var i = 0; i < numCharsToWrite; ++i) {
    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    HEAP16[((outPtr)>>1)]=codeUnit;
    outPtr += 2;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP16[((outPtr)>>1)]=0;
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF16(str) {
  return str.length*2;
}

function UTF32ToString(ptr) {
  var i = 0;

  var str = '';
  while (1) {
    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];
    if (utf32 == 0)
      return str;
    ++i;
    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    if (utf32 >= 0x10000) {
      var ch = utf32 - 0x10000;
      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
    } else {
      str += String.fromCharCode(utf32);
    }
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.
// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF32(str, outPtr, maxBytesToWrite) {
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 4) return 0;
  var startPtr = outPtr;
  var endPtr = startPtr + maxBytesToWrite - 4;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {
      var trailSurrogate = str.charCodeAt(++i);
      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);
    }
    HEAP32[((outPtr)>>2)]=codeUnit;
    outPtr += 4;
    if (outPtr + 4 > endPtr) break;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP32[((outPtr)>>2)]=0;
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF32(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i);
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.
    len += 4;
  }

  return len;
}

// Allocate heap space for a JS string, and write it there.
// It is the responsibility of the caller to free() that memory.
function allocateUTF8(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = _malloc(size);
  if (ret) stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

// Allocate stack space for a JS string, and write it there.
function allocateUTF8OnStack(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = stackAlloc(size);
  stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

// Deprecated: This function should not be called because it is unsafe and does not provide
// a maximum length limit of how many bytes it is allowed to write. Prefer calling the
// function stringToUTF8Array() instead, which takes in a maximum length that can be used
// to be secure from out of bounds writes.
/** @deprecated */
function writeStringToMemory(string, buffer, dontAddNull) {
  warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');

  var /** @type {number} */ lastChar, /** @type {number} */ end;
  if (dontAddNull) {
    // stringToUTF8Array always appends null. If we don't want to do that, remember the
    // character that existed at the location where the null will be placed, and restore
    // that after the write (below).
    end = buffer + lengthBytesUTF8(string);
    lastChar = HEAP8[end];
  }
  stringToUTF8(string, buffer, Infinity);
  if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.
}

function writeArrayToMemory(array, buffer) {
  HEAP8.set(array, buffer);
}

function writeAsciiToMemory(str, buffer, dontAddNull) {
  for (var i = 0; i < str.length; ++i) {
    HEAP8[((buffer++)>>0)]=str.charCodeAt(i);
  }
  // Null-terminate the pointer to the HEAP.
  if (!dontAddNull) HEAP8[((buffer)>>0)]=0;
}





function demangle(func) {
  return func;
}

function demangleAll(text) {
  var regex =
    /__Z[\w\d_]+/g;
  return text.replace(regex,
    function(x) {
      var y = demangle(x);
      return x === y ? x : (y + ' [' + x + ']');
    });
}

function jsStackTrace() {
  var err = new Error();
  if (!err.stack) {
    // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,
    // so try that as a special-case.
    try {
      throw new Error(0);
    } catch(e) {
      err = e;
    }
    if (!err.stack) {
      return '(no stack trace available)';
    }
  }
  return err.stack.toString();
}

function stackTrace() {
  var js = jsStackTrace();
  if (Module['extraStackTrace']) js += '\n' + Module['extraStackTrace']();
  return demangleAll(js);
}



// Memory management

var PAGE_SIZE = 16384;
var WASM_PAGE_SIZE = 65536;
var ASMJS_PAGE_SIZE = 16777216;

function alignUp(x, multiple) {
  if (x % multiple > 0) {
    x += multiple - (x % multiple);
  }
  return x;
}

var HEAP,
/** @type {ArrayBuffer} */
  buffer,
/** @type {Int8Array} */
  HEAP8,
/** @type {Uint8Array} */
  HEAPU8,
/** @type {Int16Array} */
  HEAP16,
/** @type {Uint16Array} */
  HEAPU16,
/** @type {Int32Array} */
  HEAP32,
/** @type {Uint32Array} */
  HEAPU32,
/** @type {Float32Array} */
  HEAPF32,
/** @type {Float64Array} */
  HEAPF64;

function updateGlobalBufferViews() {
  Module['HEAP8'] = HEAP8 = new Int8Array(buffer);
  Module['HEAP16'] = HEAP16 = new Int16Array(buffer);
  Module['HEAP32'] = HEAP32 = new Int32Array(buffer);
  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buffer);
  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buffer);
  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buffer);
  Module['HEAPF32'] = HEAPF32 = new Float32Array(buffer);
  Module['HEAPF64'] = HEAPF64 = new Float64Array(buffer);
}


var STATIC_BASE = 1024,
    STACK_BASE = 97488,
    STACKTOP = STACK_BASE,
    STACK_MAX = 5340368,
    DYNAMIC_BASE = 5340368,
    DYNAMICTOP_PTR = 97232;




var TOTAL_STACK = 5242880;

var INITIAL_TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 16777216;
if (INITIAL_TOTAL_MEMORY < TOTAL_STACK) err('TOTAL_MEMORY should be larger than TOTAL_STACK, was ' + INITIAL_TOTAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')');

// Initialize the runtime's memory







// Use a provided buffer, if there is one, or else allocate a new one
if (Module['buffer']) {
  buffer = Module['buffer'];
} else {
  // Use a WebAssembly memory where available
  if (typeof WebAssembly === 'object' && typeof WebAssembly.Memory === 'function') {
    wasmMemory = new WebAssembly.Memory({ 'initial': INITIAL_TOTAL_MEMORY / WASM_PAGE_SIZE });
    buffer = wasmMemory.buffer;
  } else
  {
    buffer = new ArrayBuffer(INITIAL_TOTAL_MEMORY);
  }
}
updateGlobalBufferViews();


HEAP32[DYNAMICTOP_PTR>>2] = DYNAMIC_BASE;






// Endianness check (note: assumes compiler arch was little-endian)

function callRuntimeCallbacks(callbacks) {
  while(callbacks.length > 0) {
    var callback = callbacks.shift();
    if (typeof callback == 'function') {
      callback();
      continue;
    }
    var func = callback.func;
    if (typeof func === 'number') {
      if (callback.arg === undefined) {
        Module['dynCall_v'](func);
      } else {
        Module['dynCall_vi'](func, callback.arg);
      }
    } else {
      func(callback.arg === undefined ? null : callback.arg);
    }
  }
}

var __ATPRERUN__  = []; // functions called before the runtime is initialized
var __ATINIT__    = []; // functions called during startup
var __ATMAIN__    = []; // functions called when main() is to be run
var __ATEXIT__    = []; // functions called during shutdown
var __ATPOSTRUN__ = []; // functions called after the main() is called

var runtimeInitialized = false;
var runtimeExited = false;


function preRun() {
  // compatibility - merge in anything from Module['preRun'] at this time
  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }
  callRuntimeCallbacks(__ATPRERUN__);
}

function ensureInitRuntime() {
  if (runtimeInitialized) return;
  runtimeInitialized = true;
  
  callRuntimeCallbacks(__ATINIT__);
}

function preMain() {
  
  callRuntimeCallbacks(__ATMAIN__);
}

function exitRuntime() {
  runtimeExited = true;
}

function postRun() {
  // compatibility - merge in anything from Module['postRun'] at this time
  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }
  callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}

function addOnInit(cb) {
  __ATINIT__.unshift(cb);
}

function addOnPreMain(cb) {
  __ATMAIN__.unshift(cb);
}

function addOnExit(cb) {
}

function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}

function unSign(value, bits, ignore) {
  if (value >= 0) {
    return value;
  }
  return bits <= 32 ? 2*Math.abs(1 << (bits-1)) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts
                    : Math.pow(2, bits)         + value;
}
function reSign(value, bits, ignore) {
  if (value <= 0) {
    return value;
  }
  var half = bits <= 32 ? Math.abs(1 << (bits-1)) // abs is needed if bits == 32
                        : Math.pow(2, bits-1);
  if (value >= half && (bits <= 32 || value > half)) { // for huge values, we can hit the precision limit and always get true here. so don't do that
                                                       // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors
                                                       // TODO: In i64 mode 1, resign the two parts separately and safely
    value = -2*half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts
  }
  return value;
}



var Math_abs = Math.abs;
var Math_cos = Math.cos;
var Math_sin = Math.sin;
var Math_tan = Math.tan;
var Math_acos = Math.acos;
var Math_asin = Math.asin;
var Math_atan = Math.atan;
var Math_atan2 = Math.atan2;
var Math_exp = Math.exp;
var Math_log = Math.log;
var Math_sqrt = Math.sqrt;
var Math_ceil = Math.ceil;
var Math_floor = Math.floor;
var Math_pow = Math.pow;
var Math_imul = Math.imul;
var Math_fround = Math.fround;
var Math_round = Math.round;
var Math_min = Math.min;
var Math_max = Math.max;
var Math_clz32 = Math.clz32;
var Math_trunc = Math.trunc;



// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// Module.preRun (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled

function getUniqueRunDependency(id) {
  return id;
}

function addRunDependency(id) {
  runDependencies++;
  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }
}

function removeRunDependency(id) {
  runDependencies--;
  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }
  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); // can add another dependenciesFulfilled
    }
  }
}

Module["preloadedImages"] = {}; // maps url to image data
Module["preloadedAudios"] = {}; // maps url to audio data


var memoryInitializer = null;






// Copyright 2017 The Emscripten Authors.  All rights reserved.
// Emscripten is available under two separate licenses, the MIT license and the
// University of Illinois/NCSA Open Source License.  Both these licenses can be
// found in the LICENSE file.

// Prefix of data URIs emitted by SINGLE_FILE and related options.
var dataURIPrefix = 'data:application/octet-stream;base64,';

// Indicates whether filename is a base64 data URI.
function isDataURI(filename) {
  return String.prototype.startsWith ?
      filename.startsWith(dataURIPrefix) :
      filename.indexOf(dataURIPrefix) === 0;
}




var wasmBinaryFile = 'data:application/octet-stream;base64,AGFzbQEAAAABtQEaYAR/f39/AGAGf39/f39/AGAFf39/f38AYAN/f38Bf2ABfwBgAn9/AGADf39/AGAAAX9gAX8Bf2ABfAF8YAAAYAJ/fwF/YAN/f38BfWAIf39/f39/f38Bf2ABfQF9YAd/f39/f399AX1gA319fQF9YAV/f39/fwF/YAZ/f39/f38Bf2ACfH8BfGACfHwBfGACfH8Bf2ADfHx/AXxgBH9/f38Bf2AHf39/f39/fwBgA39/fwF8ArcEFgNlbnYFYWJvcnQABANlbnYLX19fc2V0RXJyTm8ABANlbnYWX19lbWJpbmRfcmVnaXN0ZXJfYm9vbAACA2VudhdfX2VtYmluZF9yZWdpc3Rlcl9lbXZhbAAFA2VudhdfX2VtYmluZF9yZWdpc3Rlcl9mbG9hdAAGA2VudhlfX2VtYmluZF9yZWdpc3Rlcl9pbnRlZ2VyAAIDZW52HV9fZW1iaW5kX3JlZ2lzdGVyX21lbW9yeV92aWV3AAYDZW52HF9fZW1iaW5kX3JlZ2lzdGVyX3N0ZF9zdHJpbmcABQNlbnYdX19lbWJpbmRfcmVnaXN0ZXJfc3RkX3dzdHJpbmcABgNlbnYWX19lbWJpbmRfcmVnaXN0ZXJfdm9pZAAFA2VudhlfZW1zY3JpcHRlbl9nZXRfaGVhcF9zaXplAAcDZW52Fl9lbXNjcmlwdGVuX21lbWNweV9iaWcAAwNlbnYXX2Vtc2NyaXB0ZW5fcmVzaXplX2hlYXAACANlbnYPX2xsdm1fbG9nMTBfZjY0AAkDZW52El9sbHZtX3N0YWNrcmVzdG9yZQAEA2Vudg9fbGx2bV9zdGFja3NhdmUABwNlbnYKX2xsdm1fdHJhcAAKA2VudhdhYm9ydE9uQ2Fubm90R3Jvd01lbW9yeQAIA2VudgxfX3RhYmxlX2Jhc2UDfwADZW52DkRZTkFNSUNUT1BfUFRSA38AA2VudgZtZW1vcnkCAIACA2VudgV0YWJsZQFwARgYA78BvQEICAcEBQUGBQsIBAEMBg0GBQQKAAUFBg4ODgYAAAICAAwCAg8BEBEFCwAFBQYBAQEGBhIKCgQHBwoKCgoKCgoKCgoKBwcHBwoEBAQEBAQKCgoKCgcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcH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IQMMBAsACyAKKAIAQQFGDQQgCSgCAEECcUUNBEEBIQBBAQshAwsgBUEIaiEFDAELCyAARQRAIAsgAjYCACABQShqIgAgACgCAEEBajYCACABQSRqKAIAQQFGBEAgCigCAEECRgRAIAhBAToAACADDQNBBAwECwsLIAMNAEEEDAELQQMLNgIADAILCyADQQFGBEAgAUEgakEBNgIACwsLC38BAn8gACABQQhqKAIAQQAQsAEEQEEAIAEgAiADELEBBQJAIABBEGogAEEMaigCACIEQQN0aiEFIABBEGogASACIAMQvQEgBEEBSgRAIAFBNmohBCAAQRhqIQADQCAAIAEgAiADEL0BIAQsAAANAiAAQQhqIgAgBUkNAAsLCwsLWAEDfyAAQQRqKAIAIgVBCHUhBCAFQQFxBEAgBCACKAIAaigCACEECyAAKAIAIgAoAgBBHGooAgAhBiAAIAEgAiAEaiADQQIgBUECcRsgBkEDcUEMahEAAAtcAQN/IABBBGooAgAiB0EIdSEGIAdBAXEEQCADKAIAIAZqKAIAIQYLIAAoAgAiACgCAEEUaigCACEIIAAgASACIAMgBmogBEECIAdBAnEbIAUgCEEDcUEUahEBAAtaAQN/IABBBGooAgAiBkEIdSEFIAZBAXEEQCACKAIAIAVqKAIAIQULIAAoAgAiACgCAEEYaigCACEHIAAgASACIAVqIANBAiAGQQJxGyAEIAdBA3FBEGoRAgALxgMBA38gAkGAwABOBEAgACABIAIQCxogAA8LIAAhBCAAIAJqIQMgAEEDcSABQQNxRgRAA0AgAEEDcQRAIAJFBEAgBA8LIAAgASwAADoAACAAQQFqIQAgAUEBaiEBIAJBAWshAgwBCwsgA0F8cSICQUBqIQUDQCAAIAVMBEAgACABKAIANgIAIAAgASgCBDYCBCAAIAEoAgg2AgggACABKAIMNgIMIAAgASgCEDYCECAAIAEoAhQ2AhQgACABKAIYNgIYIAAgASgCHDYCHCAAIAEoAiA2AiAgACABKAIkNgIkIAAgASgCKDYCKCAAIAEoAiw2AiwgACABKAIwNgIwIAAgASgCNDYCNCAAIAEoAjg2AjggACABKAI8NgI8IABBQGshACABQUBrIQEMAQsLA0AgACACSARAIAAgASgCADYCACAAQQRqIQAgAUEEaiEBDAEL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AAACAAAAQP0AAND9AABwMAEAWgAAADAAAAACAAAA4A8AAAARAABAkQAAcgAAAGAAAAAAAAAAgAcAAKAHAABgAAAAFgAAAAEAAACwYQEAYAcAABgAAAABAAAAAQAAAAAAAACoXwEAAQAAAAIAAAADAAAABAAAAAEAAAABAAAAAQAAAAEAAAAAAAAA0F8BAAEAAAAFAAAAAwAAAAQAAAABAAAAAgAAAAIAAAACAAAAAAAAAOBfAQABAAAABgAAAAMAAAAEAAAAAgAAAAAAAABYYAEAAQAAAAcAAAADAAAABAAAAAEAAAADAAAAAwAAAAMAAACvdm9pZABib29sAHN0ZDo6c3RyaW5nAHN0ZDo6YmFzaWNfc3RyaW5nPHVuc2lnbmVkIGNoYXI+AHN0ZDo6d3N0cmluZwBlbXNjcmlwdGVuOjp2YWwAZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQzMl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxsb25nIGRvdWJsZT4ATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJZUVFAGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGRvdWJsZT4ATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJZEVFAGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGZsb2F0PgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lmRUUAZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgbG9uZz4ATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJbUVFAGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGxvbmc+AE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWxFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lqRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJaUVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXRFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lzRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJaEVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWFFRQBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxjaGFyPgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0ljRUUATjEwZW1zY3JpcHRlbjN2YWxFAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0l3TlNfMTFjaGFyX3RyYWl0c0l3RUVOU185YWxsb2NhdG9ySXdFRUVFAE5TdDNfXzIyMV9fYmFzaWNfc3RyaW5nX2NvbW1vbklMYjFFRUUATlN0M19fMjEyYmFzaWNfc3RyaW5nSWhOU18xMWNoYXJfdHJhaXRzSWhFRU5TXzlhbGxvY2F0b3JJaEVFRUUATlN0M19fMjEyYmFzaWNfc3RyaW5nSWNOU18xMWNoYXJfdHJhaXRzSWNFRU5TXzlhbGxvY2F0b3JJY0VFRUUAZG91YmxlAGZsb2F0AHVuc2lnbmVkIGxvbmcAbG9uZwB1bnNpZ25lZCBpbnQAaW50AHVuc2lnbmVkIHNob3J0AHNob3J0AHVuc2lnbmVkIGNoYXIAc2lnbmVkIGNoYXIAY2hhcgBOMTBfX2N4eGFiaXYxMTZfX3NoaW1fdHlwZV9pbmZvRQBTdDl0eXBlX2luZm8ATjEwX19jeHhhYml2MTIwX19zaV9jbGFzc190eXBlX2luZm9FAE4xMF9fY3h4YWJpdjExN19fY2xhc3NfdHlwZV9pbmZvRQBOMTBfX2N4eGFiaXYxMjNfX2Z1bmRhbWVudGFsX3R5cGVfaW5mb0UAdgBiAGMAaABhAHMAdABpAGoAbABtAGYAZABOMTBfX2N4eGFiaXYxMjFfX3ZtaV9jbGFzc190eXBlX2luZm9F';
if (!isDataURI(wasmBinaryFile)) {
  wasmBinaryFile = locateFile(wasmBinaryFile);
}

function getBinary() {
  try {
    if (Module['wasmBinary']) {
      return new Uint8Array(Module['wasmBinary']);
    }
    var binary = tryParseAsDataURI(wasmBinaryFile);
    if (binary) {
      return binary;
    }
    if (Module['readBinary']) {
      return Module['readBinary'](wasmBinaryFile);
    } else {
      throw "sync fetching of the wasm failed: you can preload it to Module['wasmBinary'] manually, or emcc.py will do that for you when generating HTML (but not JS)";
    }
  }
  catch (err) {
    abort(err);
  }
}

function getBinaryPromise() {
  // if we don't have the binary yet, and have the Fetch api, use that
  // in some environments, like Electron's render process, Fetch api may be present, but have a different context than expected, let's only use it on the Web
  if (!Module['wasmBinary'] && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === 'function') {
    return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {
      if (!response['ok']) {
        throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
      }
      return response['arrayBuffer']();
    }).catch(function () {
      return getBinary();
    });
  }
  // Otherwise, getBinary should be able to get it synchronously
  return new Promise(function(resolve, reject) {
    resolve(getBinary());
  });
}

// Create the wasm instance.
// Receives the wasm imports, returns the exports.
function createWasm(env) {
  // prepare imports
  var info = {
    'env': env
    ,
    'global': {
      'NaN': NaN,
      'Infinity': Infinity
    },
    'global.Math': Math,
    'asm2wasm': asm2wasmImports
  };
  // Load the wasm module and create an instance of using native support in the JS engine.
  // handle a generated wasm instance, receiving its exports and
  // performing other necessary setup
  function receiveInstance(instance, module) {
    var exports = instance.exports;
    Module['asm'] = exports;
    removeRunDependency('wasm-instantiate');
  }
  addRunDependency('wasm-instantiate');

  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
  // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel
  // to any other async startup actions they are performing.
  if (Module['instantiateWasm']) {
    try {
      return Module['instantiateWasm'](info, receiveInstance);
    } catch(e) {
      err('Module.instantiateWasm callback failed with error: ' + e);
      return false;
    }
  }

  var instance;
  var module;
  try {
    module = new WebAssembly.Module(getBinary());
    instance = new WebAssembly.Instance(module, info)
  } catch (e) {
    err('failed to compile wasm module: ' + e);
    if (e.toString().indexOf('imported Memory with incompatible size') >= 0) {
      err('Memory size incompatibility issues may be due to changing TOTAL_MEMORY at runtime to something too large. Use ALLOW_MEMORY_GROWTH to allow any size memory (and also make sure not to set TOTAL_MEMORY at runtime to something smaller than it was at compile time).');
    }
    return false;
  }
  receiveInstance(instance, module);
  return Module['asm']; // exports were assigned here
}

// Provide an "asm.js function" for the application, called to "link" the asm.js module. We instantiate
// the wasm module at that time, and it receives imports and provides exports and so forth, the app
// doesn't need to care that it is wasm or asm.js.

Module['asm'] = function(global, env, providedBuffer) {
  // memory was already allocated (so js could use the buffer)
  env['memory'] = wasmMemory
  ;
  // import table
  env['table'] = wasmTable = new WebAssembly.Table({
    'initial': 24,
    'maximum': 24,
    'element': 'anyfunc'
  });
  env['__memory_base'] = 1024; // tell the memory segments where to place themselves
  env['__table_base'] = 0; // table starts at 0 by default (even in dynamic linking, for the main module)

  var exports = createWasm(env);
  return exports;
};

// === Body ===

var ASM_CONSTS = [];





// STATICTOP = STATIC_BASE + 96464;
/* global initializers */  __ATINIT__.push({ func: function() { __GLOBAL__sub_I_bind_cpp() } });








/* no memory initializer */
var tempDoublePtr = 97472

function copyTempFloat(ptr) { // functions, because inlining this code increases code size too much
  HEAP8[tempDoublePtr] = HEAP8[ptr];
  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];
  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];
  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];
}

function copyTempDouble(ptr) {
  HEAP8[tempDoublePtr] = HEAP8[ptr];
  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];
  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];
  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];
  HEAP8[tempDoublePtr+4] = HEAP8[ptr+4];
  HEAP8[tempDoublePtr+5] = HEAP8[ptr+5];
  HEAP8[tempDoublePtr+6] = HEAP8[ptr+6];
  HEAP8[tempDoublePtr+7] = HEAP8[ptr+7];
}

// {{PRE_LIBRARY}}


  
  function __ZSt18uncaught_exceptionv() { // std::uncaught_exception()
      return !!__ZSt18uncaught_exceptionv.uncaught_exception;
    }
  
  
  
  
  function ___cxa_free_exception(ptr) {
      try {
        return _free(ptr);
      } catch(e) { // XXX FIXME
      }
    }var EXCEPTIONS={last:0,caught:[],infos:{},deAdjust:function (adjusted) {
        if (!adjusted || EXCEPTIONS.infos[adjusted]) return adjusted;
        for (var key in EXCEPTIONS.infos) {
          var ptr = +key; // the iteration key is a string, and if we throw this, it must be an integer as that is what we look for
          var adj = EXCEPTIONS.infos[ptr].adjusted;
          var len = adj.length;
          for (var i = 0; i < len; i++) {
            if (adj[i] === adjusted) {
              return ptr;
            }
          }
        }
        return adjusted;
      },addRef:function (ptr) {
        if (!ptr) return;
        var info = EXCEPTIONS.infos[ptr];
        info.refcount++;
      },decRef:function (ptr) {
        if (!ptr) return;
        var info = EXCEPTIONS.infos[ptr];
        assert(info.refcount > 0);
        info.refcount--;
        // A rethrown exception can reach refcount 0; it must not be discarded
        // Its next handler will clear the rethrown flag and addRef it, prior to
        // final decRef and destruction here
        if (info.refcount === 0 && !info.rethrown) {
          if (info.destructor) {
            Module['dynCall_vi'](info.destructor, ptr);
          }
          delete EXCEPTIONS.infos[ptr];
          ___cxa_free_exception(ptr);
        }
      },clearRef:function (ptr) {
        if (!ptr) return;
        var info = EXCEPTIONS.infos[ptr];
        info.refcount = 0;
      }};
  function ___resumeException(ptr) {
      if (!EXCEPTIONS.last) { EXCEPTIONS.last = ptr; }
      throw ptr;
    }function ___cxa_find_matching_catch() {
      var thrown = EXCEPTIONS.last;
      if (!thrown) {
        // just pass through the null ptr
        return ((setTempRet0(0),0)|0);
      }
      var info = EXCEPTIONS.infos[thrown];
      var throwntype = info.type;
      if (!throwntype) {
        // just pass through the thrown ptr
        return ((setTempRet0(0),thrown)|0);
      }
      var typeArray = Array.prototype.slice.call(arguments);
  
      var pointer = Module['___cxa_is_pointer_type'](throwntype);
      // can_catch receives a **, add indirection
      if (!___cxa_find_matching_catch.buffer) ___cxa_find_matching_catch.buffer = _malloc(4);
      HEAP32[((___cxa_find_matching_catch.buffer)>>2)]=thrown;
      thrown = ___cxa_find_matching_catch.buffer;
      // The different catch blocks are denoted by different types.
      // Due to inheritance, those types may not precisely match the
      // type of the thrown object. Find one which matches, and
      // return the type of the catch block which should be called.
      for (var i = 0; i < typeArray.length; i++) {
        if (typeArray[i] && Module['___cxa_can_catch'](typeArray[i], throwntype, thrown)) {
          thrown = HEAP32[((thrown)>>2)]; // undo indirection
          info.adjusted.push(thrown);
          return ((setTempRet0(typeArray[i]),thrown)|0);
        }
      }
      // Shouldn't happen unless we have bogus data in typeArray
      // or encounter a type for which emscripten doesn't have suitable
      // typeinfo defined. Best-efforts match just in case.
      thrown = HEAP32[((thrown)>>2)]; // undo indirection
      return ((setTempRet0(throwntype),thrown)|0);
    }function ___gxx_personality_v0() {
    }

  
  function getShiftFromSize(size) {
      switch (size) {
          case 1: return 0;
          case 2: return 1;
          case 4: return 2;
          case 8: return 3;
          default:
              throw new TypeError('Unknown type size: ' + size);
      }
    }
  
  
  
  function embind_init_charCodes() {
      var codes = new Array(256);
      for (var i = 0; i < 256; ++i) {
          codes[i] = String.fromCharCode(i);
      }
      embind_charCodes = codes;
    }var embind_charCodes=undefined;function readLatin1String(ptr) {
      var ret = "";
      var c = ptr;
      while (HEAPU8[c]) {
          ret += embind_charCodes[HEAPU8[c++]];
      }
      return ret;
    }
  
  
  var awaitingDependencies={};
  
  var registeredTypes={};
  
  var typeDependencies={};
  
  
  
  
  
  
  var char_0=48;
  
  var char_9=57;function makeLegalFunctionName(name) {
      if (undefined === name) {
          return '_unknown';
      }
      name = name.replace(/[^a-zA-Z0-9_]/g, '$');
      var f = name.charCodeAt(0);
      if (f >= char_0 && f <= char_9) {
          return '_' + name;
      } else {
          return name;
      }
    }function createNamedFunction(name, body) {
      name = makeLegalFunctionName(name);
      /*jshint evil:true*/
      return new Function(
          "body",
          "return function " + name + "() {\n" +
          "    \"use strict\";" +
          "    return body.apply(this, arguments);\n" +
          "};\n"
      )(body);
    }function extendError(baseErrorType, errorName) {
      var errorClass = createNamedFunction(errorName, function(message) {
          this.name = errorName;
          this.message = message;
  
          var stack = (new Error(message)).stack;
          if (stack !== undefined) {
              this.stack = this.toString() + '\n' +
                  stack.replace(/^Error(:[^\n]*)?\n/, '');
          }
      });
      errorClass.prototype = Object.create(baseErrorType.prototype);
      errorClass.prototype.constructor = errorClass;
      errorClass.prototype.toString = function() {
          if (this.message === undefined) {
              return this.name;
          } else {
              return this.name + ': ' + this.message;
          }
      };
  
      return errorClass;
    }var BindingError=undefined;function throwBindingError(message) {
      throw new BindingError(message);
    }
  
  
  
  var InternalError=undefined;function throwInternalError(message) {
      throw new InternalError(message);
    }function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {
      myTypes.forEach(function(type) {
          typeDependencies[type] = dependentTypes;
      });
  
      function onComplete(typeConverters) {
          var myTypeConverters = getTypeConverters(typeConverters);
          if (myTypeConverters.length !== myTypes.length) {
              throwInternalError('Mismatched type converter count');
          }
          for (var i = 0; i < myTypes.length; ++i) {
              registerType(myTypes[i], myTypeConverters[i]);
          }
      }
  
      var typeConverters = new Array(dependentTypes.length);
      var unregisteredTypes = [];
      var registered = 0;
      dependentTypes.forEach(function(dt, i) {
          if (registeredTypes.hasOwnProperty(dt)) {
              typeConverters[i] = registeredTypes[dt];
          } else {
              unregisteredTypes.push(dt);
              if (!awaitingDependencies.hasOwnProperty(dt)) {
                  awaitingDependencies[dt] = [];
              }
              awaitingDependencies[dt].push(function() {
                  typeConverters[i] = registeredTypes[dt];
                  ++registered;
                  if (registered === unregisteredTypes.length) {
                      onComplete(typeConverters);
                  }
              });
          }
      });
      if (0 === unregisteredTypes.length) {
          onComplete(typeConverters);
      }
    }function registerType(rawType, registeredInstance, options) {
      options = options || {};
  
      if (!('argPackAdvance' in registeredInstance)) {
          throw new TypeError('registerType registeredInstance requires argPackAdvance');
      }
  
      var name = registeredInstance.name;
      if (!rawType) {
          throwBindingError('type "' + name + '" must have a positive integer typeid pointer');
      }
      if (registeredTypes.hasOwnProperty(rawType)) {
          if (options.ignoreDuplicateRegistrations) {
              return;
          } else {
              throwBindingError("Cannot register type '" + name + "' twice");
          }
      }
  
      registeredTypes[rawType] = registeredInstance;
      delete typeDependencies[rawType];
  
      if (awaitingDependencies.hasOwnProperty(rawType)) {
          var callbacks = awaitingDependencies[rawType];
          delete awaitingDependencies[rawType];
          callbacks.forEach(function(cb) {
              cb();
          });
      }
    }function __embind_register_bool(rawType, name, size, trueValue, falseValue) {
      var shift = getShiftFromSize(size);
  
      name = readLatin1String(name);
      registerType(rawType, {
          name: name,
          'fromWireType': function(wt) {
              // ambiguous emscripten ABI: sometimes return values are
              // true or false, and sometimes integers (0 or 1)
              return !!wt;
          },
          'toWireType': function(destructors, o) {
              return o ? trueValue : falseValue;
          },
          'argPackAdvance': 8,
          'readValueFromPointer': function(pointer) {
              // TODO: if heap is fixed (like in asm.js) this could be executed outside
              var heap;
              if (size === 1) {
                  heap = HEAP8;
              } else if (size === 2) {
                  heap = HEAP16;
              } else if (size === 4) {
                  heap = HEAP32;
              } else {
                  throw new TypeError("Unknown boolean type size: " + name);
              }
              return this['fromWireType'](heap[pointer >> shift]);
          },
          destructorFunction: null, // This type does not need a destructor
      });
    }

  
  
  var emval_free_list=[];
  
  var emval_handle_array=[{},{value:undefined},{value:null},{value:true},{value:false}];function __emval_decref(handle) {
      if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {
          emval_handle_array[handle] = undefined;
          emval_free_list.push(handle);
      }
    }
  
  
  
  function count_emval_handles() {
      var count = 0;
      for (var i = 5; i < emval_handle_array.length; ++i) {
          if (emval_handle_array[i] !== undefined) {
              ++count;
          }
      }
      return count;
    }
  
  function get_first_emval() {
      for (var i = 5; i < emval_handle_array.length; ++i) {
          if (emval_handle_array[i] !== undefined) {
              return emval_handle_array[i];
          }
      }
      return null;
    }function init_emval() {
      Module['count_emval_handles'] = count_emval_handles;
      Module['get_first_emval'] = get_first_emval;
    }function __emval_register(value) {
  
      switch(value){
        case undefined :{ return 1; }
        case null :{ return 2; }
        case true :{ return 3; }
        case false :{ return 4; }
        default:{
          var handle = emval_free_list.length ?
              emval_free_list.pop() :
              emval_handle_array.length;
  
          emval_handle_array[handle] = {refcount: 1, value: value};
          return handle;
          }
        }
    }
  
  function simpleReadValueFromPointer(pointer) {
      return this['fromWireType'](HEAPU32[pointer >> 2]);
    }function __embind_register_emval(rawType, name) {
      name = readLatin1String(name);
      registerType(rawType, {
          name: name,
          'fromWireType': function(handle) {
              var rv = emval_handle_array[handle].value;
              __emval_decref(handle);
              return rv;
          },
          'toWireType': function(destructors, value) {
              return __emval_register(value);
          },
          'argPackAdvance': 8,
          'readValueFromPointer': simpleReadValueFromPointer,
          destructorFunction: null, // This type does not need a destructor
  
          // TODO: do we need a deleteObject here?  write a test where
          // emval is passed into JS via an interface
      });
    }

  
  function _embind_repr(v) {
      if (v === null) {
          return 'null';
      }
      var t = typeof v;
      if (t === 'object' || t === 'array' || t === 'function') {
          return v.toString();
      } else {
          return '' + v;
      }
    }
  
  function floatReadValueFromPointer(name, shift) {
      switch (shift) {
          case 2: return function(pointer) {
              return this['fromWireType'](HEAPF32[pointer >> 2]);
          };
          case 3: return function(pointer) {
              return this['fromWireType'](HEAPF64[pointer >> 3]);
          };
          default:
              throw new TypeError("Unknown float type: " + name);
      }
    }function __embind_register_float(rawType, name, size) {
      var shift = getShiftFromSize(size);
      name = readLatin1String(name);
      registerType(rawType, {
          name: name,
          'fromWireType': function(value) {
              return value;
          },
          'toWireType': function(destructors, value) {
              // todo: Here we have an opportunity for -O3 level "unsafe" optimizations: we could
              // avoid the following if() and assume value is of proper type.
              if (typeof value !== "number" && typeof value !== "boolean") {
                  throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
              }
              return value;
          },
          'argPackAdvance': 8,
          'readValueFromPointer': floatReadValueFromPointer(name, shift),
          destructorFunction: null, // This type does not need a destructor
      });
    }

  
  function integerReadValueFromPointer(name, shift, signed) {
      // integers are quite common, so generate very specialized functions
      switch (shift) {
          case 0: return signed ?
              function readS8FromPointer(pointer) { return HEAP8[pointer]; } :
              function readU8FromPointer(pointer) { return HEAPU8[pointer]; };
          case 1: return signed ?
              function readS16FromPointer(pointer) { return HEAP16[pointer >> 1]; } :
              function readU16FromPointer(pointer) { return HEAPU16[pointer >> 1]; };
          case 2: return signed ?
              function readS32FromPointer(pointer) { return HEAP32[pointer >> 2]; } :
              function readU32FromPointer(pointer) { return HEAPU32[pointer >> 2]; };
          default:
              throw new TypeError("Unknown integer type: " + name);
      }
    }function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {
      name = readLatin1String(name);
      if (maxRange === -1) { // LLVM doesn't have signed and unsigned 32-bit types, so u32 literals come out as 'i32 -1'. Always treat those as max u32.
          maxRange = 4294967295;
      }
  
      var shift = getShiftFromSize(size);
  
      var fromWireType = function(value) {
          return value;
      };
  
      if (minRange === 0) {
          var bitshift = 32 - 8*size;
          fromWireType = function(value) {
              return (value << bitshift) >>> bitshift;
          };
      }
  
      var isUnsignedType = (name.indexOf('unsigned') != -1);
  
      registerType(primitiveType, {
          name: name,
          'fromWireType': fromWireType,
          'toWireType': function(destructors, value) {
              // todo: Here we have an opportunity for -O3 level "unsafe" optimizations: we could
              // avoid the following two if()s and assume value is of proper type.
              if (typeof value !== "number" && typeof value !== "boolean") {
                  throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
              }
              if (value < minRange || value > maxRange) {
                  throw new TypeError('Passing a number "' + _embind_repr(value) + '" from JS side to C/C++ side to an argument of type "' + name + '", which is outside the valid range [' + minRange + ', ' + maxRange + ']!');
              }
              return isUnsignedType ? (value >>> 0) : (value | 0);
          },
          'argPackAdvance': 8,
          'readValueFromPointer': integerReadValueFromPointer(name, shift, minRange !== 0),
          destructorFunction: null, // This type does not need a destructor
      });
    }

  function __embind_register_memory_view(rawType, dataTypeIndex, name) {
      var typeMapping = [
          Int8Array,
          Uint8Array,
          Int16Array,
          Uint16Array,
          Int32Array,
          Uint32Array,
          Float32Array,
          Float64Array,
      ];
  
      var TA = typeMapping[dataTypeIndex];
  
      function decodeMemoryView(handle) {
          handle = handle >> 2;
          var heap = HEAPU32;
          var size = heap[handle]; // in elements
          var data = heap[handle + 1]; // byte offset into emscripten heap
          return new TA(heap['buffer'], data, size);
      }
  
      name = readLatin1String(name);
      registerType(rawType, {
          name: name,
          'fromWireType': decodeMemoryView,
          'argPackAdvance': 8,
          'readValueFromPointer': decodeMemoryView,
      }, {
          ignoreDuplicateRegistrations: true,
      });
    }

  function __embind_register_std_string(rawType, name) {
      name = readLatin1String(name);
      var stdStringIsUTF8
      //process only std::string bindings with UTF8 support, in contrast to e.g. std::basic_string<unsigned char>
      = (name === "std::string");
  
      registerType(rawType, {
          name: name,
          'fromWireType': function(value) {
              var length = HEAPU32[value >> 2];
  
              var str;
              if(stdStringIsUTF8) {
                  //ensure null termination at one-past-end byte if not present yet
                  var endChar = HEAPU8[value + 4 + length];
                  var endCharSwap = 0;
                  if(endChar != 0)
                  {
                    endCharSwap = endChar;
                    HEAPU8[value + 4 + length] = 0;
                  }
  
                  var decodeStartPtr = value + 4;
                  //looping here to support possible embedded '0' bytes
                  for (var i = 0; i <= length; ++i) {
                    var currentBytePtr = value + 4 + i;
                    if(HEAPU8[currentBytePtr] == 0)
                    {
                      var stringSegment = UTF8ToString(decodeStartPtr);
                      if(str === undefined)
                        str = stringSegment;
                      else
                      {
                        str += String.fromCharCode(0);
                        str += stringSegment;
                      }
                      decodeStartPtr = currentBytePtr + 1;
                    }
                  }
  
                  if(endCharSwap != 0)
                    HEAPU8[value + 4 + length] = endCharSwap;
              } else {
                  var a = new Array(length);
                  for (var i = 0; i < length; ++i) {
                      a[i] = String.fromCharCode(HEAPU8[value + 4 + i]);
                  }
                  str = a.join('');
              }
  
              _free(value);
              
              return str;
          },
          'toWireType': function(destructors, value) {
              if (value instanceof ArrayBuffer) {
                  value = new Uint8Array(value);
              }
              
              var getLength;
              var valueIsOfTypeString = (typeof value === 'string');
  
              if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
                  throwBindingError('Cannot pass non-string to std::string');
              }
              if (stdStringIsUTF8 && valueIsOfTypeString) {
                  getLength = function() {return lengthBytesUTF8(value);};
              } else {
                  getLength = function() {return value.length;};
              }
              
              // assumes 4-byte alignment
              var length = getLength();
              var ptr = _malloc(4 + length + 1);
              HEAPU32[ptr >> 2] = length;
  
              if (stdStringIsUTF8 && valueIsOfTypeString) {
                  stringToUTF8(value, ptr + 4, length + 1);
              } else {
                  if(valueIsOfTypeString) {
                      for (var i = 0; i < length; ++i) {
                          var charCode = value.charCodeAt(i);
                          if (charCode > 255) {
                              _free(ptr);
                              throwBindingError('String has UTF-16 code units that do not fit in 8 bits');
                          }
                          HEAPU8[ptr + 4 + i] = charCode;
                      }
                  } else {
                      for (var i = 0; i < length; ++i) {
                          HEAPU8[ptr + 4 + i] = value[i];
                      }
                  }
              }
  
              if (destructors !== null) {
                  destructors.push(_free, ptr);
              }
              return ptr;
          },
          'argPackAdvance': 8,
          'readValueFromPointer': simpleReadValueFromPointer,
          destructorFunction: function(ptr) { _free(ptr); },
      });
    }

  function __embind_register_std_wstring(rawType, charSize, name) {
      // nb. do not cache HEAPU16 and HEAPU32, they may be destroyed by emscripten_resize_heap().
      name = readLatin1String(name);
      var getHeap, shift;
      if (charSize === 2) {
          getHeap = function() { return HEAPU16; };
          shift = 1;
      } else if (charSize === 4) {
          getHeap = function() { return HEAPU32; };
          shift = 2;
      }
      registerType(rawType, {
          name: name,
          'fromWireType': function(value) {
              var HEAP = getHeap();
              var length = HEAPU32[value >> 2];
              var a = new Array(length);
              var start = (value + 4) >> shift;
              for (var i = 0; i < length; ++i) {
                  a[i] = String.fromCharCode(HEAP[start + i]);
              }
              _free(value);
              return a.join('');
          },
          'toWireType': function(destructors, value) {
              // assumes 4-byte alignment
              var HEAP = getHeap();
              var length = value.length;
              var ptr = _malloc(4 + length * charSize);
              HEAPU32[ptr >> 2] = length;
              var start = (ptr + 4) >> shift;
              for (var i = 0; i < length; ++i) {
                  HEAP[start + i] = value.charCodeAt(i);
              }
              if (destructors !== null) {
                  destructors.push(_free, ptr);
              }
              return ptr;
          },
          'argPackAdvance': 8,
          'readValueFromPointer': simpleReadValueFromPointer,
          destructorFunction: function(ptr) { _free(ptr); },
      });
    }

  function __embind_register_void(rawType, name) {
      name = readLatin1String(name);
      registerType(rawType, {
          isVoid: true, // void return values can be optimized out sometimes
          name: name,
          'argPackAdvance': 0,
          'fromWireType': function() {
              return undefined;
          },
          'toWireType': function(destructors, o) {
              // TODO: assert if anything else is given?
              return undefined;
          },
      });
    }

  function _emscripten_get_heap_size() {
      return HEAP8.length;
    }

  
  function abortOnCannotGrowMemory(requestedSize) {
      abort('OOM');
    }
  
  function emscripten_realloc_buffer(size) {
      var PAGE_MULTIPLE = 65536;
      size = alignUp(size, PAGE_MULTIPLE); // round up to wasm page size
      var oldSize = buffer.byteLength;
      // native wasm support
      try {
        var result = wasmMemory.grow((size - oldSize) / 65536); // .grow() takes a delta compared to the previous size
        if (result !== (-1 | 0)) {
          // success in native wasm memory growth, get the buffer from the memory
          return buffer = wasmMemory.buffer;
        } else {
          return null;
        }
      } catch(e) {
        return null;
      }
    }function _emscripten_resize_heap(requestedSize) {
      var oldSize = _emscripten_get_heap_size();
  
  
      var PAGE_MULTIPLE = 65536;
      var LIMIT = 2147483648 - PAGE_MULTIPLE; // We can do one page short of 2GB as theoretical maximum.
  
      if (requestedSize > LIMIT) {
        return false;
      }
  
      var MIN_TOTAL_MEMORY = 16777216;
      var newSize = Math.max(oldSize, MIN_TOTAL_MEMORY); // So the loop below will not be infinite, and minimum asm.js memory size is 16MB.
  
      while (newSize < requestedSize) { // Keep incrementing the heap size as long as it's less than what is requested.
        if (newSize <= 536870912) {
          newSize = alignUp(2 * newSize, PAGE_MULTIPLE); // Simple heuristic: double until 1GB...
        } else {
          // ..., but after that, add smaller increments towards 2GB, which we cannot reach
          newSize = Math.min(alignUp((3 * newSize + 2147483648) / 4, PAGE_MULTIPLE), LIMIT);
        }
      }
  
  
  
      var replacement = emscripten_realloc_buffer(newSize);
      if (!replacement || replacement.byteLength != newSize) {
        return false;
      }
  
      // everything worked
      updateGlobalBufferViews();
  
  
  
      return true;
    }

  
  function _llvm_log10_f32(x) {
      return Math.log(x) / Math.LN10; // TODO: Math.log10, when browser support is there
    }function _llvm_log10_f64(a0
  /*``*/) {
  return _llvm_log10_f32(a0);
  }

  function _llvm_stackrestore(p) {
      var self = _llvm_stacksave;
      var ret = self.LLVM_SAVEDSTACKS[p];
      self.LLVM_SAVEDSTACKS.splice(p, 1);
      stackRestore(ret);
    }

  function _llvm_stacksave() {
      var self = _llvm_stacksave;
      if (!self.LLVM_SAVEDSTACKS) {
        self.LLVM_SAVEDSTACKS = [];
      }
      self.LLVM_SAVEDSTACKS.push(stackSave());
      return self.LLVM_SAVEDSTACKS.length-1;
    }

  function _llvm_trap() {
      abort('trap!');
    }

  
  function _emscripten_memcpy_big(dest, src, num) {
      HEAPU8.set(HEAPU8.subarray(src, src+num), dest);
    }
  
   

   

   

  
  function ___setErrNo(value) {
      if (Module['___errno_location']) HEAP32[((Module['___errno_location']())>>2)]=value;
      return value;
    } 
embind_init_charCodes();
BindingError = Module['BindingError'] = extendError(Error, 'BindingError');;
InternalError = Module['InternalError'] = extendError(Error, 'InternalError');;
init_emval();;
var ASSERTIONS = false;

// Copyright 2017 The Emscripten Authors.  All rights reserved.
// Emscripten is available under two separate licenses, the MIT license and the
// University of Illinois/NCSA Open Source License.  Both these licenses can be
// found in the LICENSE file.

/** @type {function(string, boolean=, number=)} */
function intArrayFromString(stringy, dontAddNull, length) {
  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;
  var u8array = new Array(len);
  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
  if (dontAddNull) u8array.length = numBytesWritten;
  return u8array;
}

function intArrayToString(array) {
  var ret = [];
  for (var i = 0; i < array.length; i++) {
    var chr = array[i];
    if (chr > 0xFF) {
      if (ASSERTIONS) {
        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');
      }
      chr &= 0xFF;
    }
    ret.push(String.fromCharCode(chr));
  }
  return ret.join('');
}


// Copied from https://github.com/strophe/strophejs/blob/e06d027/src/polyfills.js#L149

// This code was written by Tyler Akins and has been placed in the
// public domain.  It would be nice if you left this header intact.
// Base64 code from Tyler Akins -- http://rumkin.com

/**
 * Decodes a base64 string.
 * @param {String} input The string to decode.
 */
var decodeBase64 = typeof atob === 'function' ? atob : function (input) {
  var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

  var output = '';
  var chr1, chr2, chr3;
  var enc1, enc2, enc3, enc4;
  var i = 0;
  // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
  do {
    enc1 = keyStr.indexOf(input.charAt(i++));
    enc2 = keyStr.indexOf(input.charAt(i++));
    enc3 = keyStr.indexOf(input.charAt(i++));
    enc4 = keyStr.indexOf(input.charAt(i++));

    chr1 = (enc1 << 2) | (enc2 >> 4);
    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
    chr3 = ((enc3 & 3) << 6) | enc4;

    output = output + String.fromCharCode(chr1);

    if (enc3 !== 64) {
      output = output + String.fromCharCode(chr2);
    }
    if (enc4 !== 64) {
      output = output + String.fromCharCode(chr3);
    }
  } while (i < input.length);
  return output;
};

// Converts a string of base64 into a byte array.
// Throws error on invalid input.
function intArrayFromBase64(s) {
  if (typeof ENVIRONMENT_IS_NODE === 'boolean' && ENVIRONMENT_IS_NODE) {
    var buf;
    try {
      buf = Buffer.from(s, 'base64');
    } catch (_) {
      buf = new Buffer(s, 'base64');
    }
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }

  try {
    var decoded = decodeBase64(s);
    var bytes = new Uint8Array(decoded.length);
    for (var i = 0 ; i < decoded.length ; ++i) {
      bytes[i] = decoded.charCodeAt(i);
    }
    return bytes;
  } catch (_) {
    throw new Error('Converting base64 string to bytes failed.');
  }
}

// If filename is a base64 data URI, parses and returns data (Buffer on node,
// Uint8Array otherwise). If filename is not a base64 data URI, returns undefined.
function tryParseAsDataURI(filename) {
  if (!isDataURI(filename)) {
    return;
  }

  return intArrayFromBase64(filename.slice(dataURIPrefix.length));
}


// ASM_LIBRARY EXTERN PRIMITIVES: Int8Array,Int32Array


var asmGlobalArg = {}

var asmLibraryArg = {
  "abort": abort,
  "setTempRet0": setTempRet0,
  "getTempRet0": getTempRet0,
  "__ZSt18uncaught_exceptionv": __ZSt18uncaught_exceptionv,
  "___cxa_find_matching_catch": ___cxa_find_matching_catch,
  "___cxa_free_exception": ___cxa_free_exception,
  "___gxx_personality_v0": ___gxx_personality_v0,
  "___resumeException": ___resumeException,
  "___setErrNo": ___setErrNo,
  "__embind_register_bool": __embind_register_bool,
  "__embind_register_emval": __embind_register_emval,
  "__embind_register_float": __embind_register_float,
  "__embind_register_integer": __embind_register_integer,
  "__embind_register_memory_view": __embind_register_memory_view,
  "__embind_register_std_string": __embind_register_std_string,
  "__embind_register_std_wstring": __embind_register_std_wstring,
  "__embind_register_void": __embind_register_void,
  "__emval_decref": __emval_decref,
  "__emval_register": __emval_register,
  "_embind_repr": _embind_repr,
  "_emscripten_get_heap_size": _emscripten_get_heap_size,
  "_emscripten_memcpy_big": _emscripten_memcpy_big,
  "_emscripten_resize_heap": _emscripten_resize_heap,
  "_llvm_log10_f32": _llvm_log10_f32,
  "_llvm_log10_f64": _llvm_log10_f64,
  "_llvm_stackrestore": _llvm_stackrestore,
  "_llvm_stacksave": _llvm_stacksave,
  "_llvm_trap": _llvm_trap,
  "abortOnCannotGrowMemory": abortOnCannotGrowMemory,
  "count_emval_handles": count_emval_handles,
  "createNamedFunction": createNamedFunction,
  "embind_init_charCodes": embind_init_charCodes,
  "emscripten_realloc_buffer": emscripten_realloc_buffer,
  "extendError": extendError,
  "floatReadValueFromPointer": floatReadValueFromPointer,
  "getShiftFromSize": getShiftFromSize,
  "get_first_emval": get_first_emval,
  "init_emval": init_emval,
  "integerReadValueFromPointer": integerReadValueFromPointer,
  "makeLegalFunctionName": makeLegalFunctionName,
  "readLatin1String": readLatin1String,
  "registerType": registerType,
  "simpleReadValueFromPointer": simpleReadValueFromPointer,
  "throwBindingError": throwBindingError,
  "throwInternalError": throwInternalError,
  "whenDependentTypesAreResolved": whenDependentTypesAreResolved,
  "tempDoublePtr": tempDoublePtr,
  "DYNAMICTOP_PTR": DYNAMICTOP_PTR
}
// EMSCRIPTEN_START_ASM
var asm =Module["asm"]// EMSCRIPTEN_END_ASM
(asmGlobalArg, asmLibraryArg, buffer);

var __GLOBAL__sub_I_bind_cpp = Module["__GLOBAL__sub_I_bind_cpp"] = asm["__GLOBAL__sub_I_bind_cpp"];
var ___errno_location = Module["___errno_location"] = asm["___errno_location"];
var ___getTypeName = Module["___getTypeName"] = asm["___getTypeName"];
var _emscripten_replace_memory = Module["_emscripten_replace_memory"] = asm["_emscripten_replace_memory"];
var _free = Module["_free"] = asm["_free"];
var _malloc = Module["_malloc"] = asm["_malloc"];
var _memcpy = Module["_memcpy"] = asm["_memcpy"];
var _memmove = Module["_memmove"] = asm["_memmove"];
var _memset = Module["_memset"] = asm["_memset"];
var _rnnoise_create = Module["_rnnoise_create"] = asm["_rnnoise_create"];
var _rnnoise_destroy = Module["_rnnoise_destroy"] = asm["_rnnoise_destroy"];
var _rnnoise_init = Module["_rnnoise_init"] = asm["_rnnoise_init"];
var _rnnoise_process_frame = Module["_rnnoise_process_frame"] = asm["_rnnoise_process_frame"];
var _sbrk = Module["_sbrk"] = asm["_sbrk"];
var establishStackSpace = Module["establishStackSpace"] = asm["establishStackSpace"];
var stackAlloc = Module["stackAlloc"] = asm["stackAlloc"];
var stackRestore = Module["stackRestore"] = asm["stackRestore"];
var stackSave = Module["stackSave"] = asm["stackSave"];
var dynCall_iiii = Module["dynCall_iiii"] = asm["dynCall_iiii"];
var dynCall_vi = Module["dynCall_vi"] = asm["dynCall_vi"];
var dynCall_viiii = Module["dynCall_viiii"] = asm["dynCall_viiii"];
var dynCall_viiiii = Module["dynCall_viiiii"] = asm["dynCall_viiiii"];
var dynCall_viiiiii = Module["dynCall_viiiiii"] = asm["dynCall_viiiiii"];
;



// === Auto-generated postamble setup entry stuff ===

Module['asm'] = asm;














































































/**
 * @constructor
 * @extends {Error}
 * @this {ExitStatus}
 */
function ExitStatus(status) {
  this.name = "ExitStatus";
  this.message = "Program terminated with exit(" + status + ")";
  this.status = status;
};
ExitStatus.prototype = new Error();
ExitStatus.prototype.constructor = ExitStatus;

var calledMain = false;

dependenciesFulfilled = function runCaller() {
  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
  if (!Module['calledRun']) run();
  if (!Module['calledRun']) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
}





/** @type {function(Array=)} */
function run(args) {
  args = args || Module['arguments'];

  if (runDependencies > 0) {
    return;
  }


  preRun();

  if (runDependencies > 0) return; // a preRun added a dependency, run will be called later
  if (Module['calledRun']) return; // run may have just been called through dependencies being fulfilled just in this very frame

  function doRun() {
    if (Module['calledRun']) return; // run may have just been called while the async setStatus time below was happening
    Module['calledRun'] = true;

    if (ABORT) return;

    ensureInitRuntime();

    preMain();

    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();


    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function() {
      setTimeout(function() {
        Module['setStatus']('');
      }, 1);
      doRun();
    }, 1);
  } else {
    doRun();
  }
}
Module['run'] = run;


function exit(status, implicit) {

  // if this is just main exit-ing implicitly, and the status is 0, then we
  // don't need to do anything here and can just leave. if the status is
  // non-zero, though, then we need to report it.
  // (we may have warned about this earlier, if a situation justifies doing so)
  if (implicit && Module['noExitRuntime'] && status === 0) {
    return;
  }

  if (Module['noExitRuntime']) {
  } else {

    ABORT = true;
    EXITSTATUS = status;

    exitRuntime();

    if (Module['onExit']) Module['onExit'](status);
  }

  Module['quit'](status, new ExitStatus(status));
}

var abortDecorators = [];

function abort(what) {
  if (Module['onAbort']) {
    Module['onAbort'](what);
  }

  if (what !== undefined) {
    out(what);
    err(what);
    what = JSON.stringify(what)
  } else {
    what = '';
  }

  ABORT = true;
  EXITSTATUS = 1;

  throw 'abort(' + what + '). Build with -s ASSERTIONS=1 for more info.';
}
Module['abort'] = abort;

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}


  Module["noExitRuntime"] = true;

run();





// {{MODULE_ADDITIONS}}



/**
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

// EXPORT_ES6 option does not work as described at
// https://github.com/kripken/emscripten/issues/6284, so we have to
// manually add this by '--post-js' setting when the Emscripten compilation.
export default Module;

